# Some first Intel x86 assembly programs

It turns out that in spite of its reputation of being complex (and/or
ugly), it's easily possible to learn to write simple assembly programs
within a few days, if you've already done some programming in
e.g. [6502](http://en.wikipedia.org/wiki/MOS_Technology_6502) assembly.

For more complex programs, see the
[hasm](https://github.com/pflanze/hasm) repository, which also
includes (the beginnings of) a macro layer to help develop assembly
programs, and supports x86_64 as well.


## Order of exploration

1. `hello_C.c`: a simple start

2. `hello_C.s`: the assembly generated by `gcc` without optimizations. 

3. `hello.S`: reimplementation directly in assembly (manually),
leaving out all unnecessary complications, and using `push` instead of
the (in this case) unnecessarily complex separate change of the stack
pointer with `sub esp, 16` and writing to the stack with `mov DWORD
PTR [esp], ..`.

4. `evenodd_C.c`: a slightly more complicated program, using a silly
algorithm to determine evenness/oddness of a natural number. Since
this leads to deep chains of function calls, it will only work for big
numbers when the C compiler optimizes tail-calls (see 'compile
evenodd_C' below).

5. `evenodd.S`: implementation of the same directly in assembly,
enjoying the guaranteed (manual) optimization of tail-calls, and
passing arguments in registers instead of following the C calling
conventions of putting them onto the stack. Using an uppercase `.S`
suffix to instruct gcc to run the C preprocessor on the file, to
expand the TRUE and FALSE macros.


## Compilation commands

NOTE: all of this assumes that you're running a 32-bit Linux
system. If you're on 64-bit, then you'll need to install 32-bit
support libraries, e.g. on Debian:

    $ sudo apt-get install libc6-dev-i386 libc6-i386

and pass `-m32` to all gcc invocations.

There's a makefile to build binaries. Still, here's how to compile
things manually:

### compile *.S files

Running `gcc` does both call the GNU assembler `as` on the file and
then link it with the C library, which is used in some cases.

    $ gcc hello.S -o hello

### compile evenodd_C

This needs at least -O2 to optimize tail-calls between `oddP` and
`evenP`. Without optimization it will overflow the stack and get a
segv.

    $ gcc -Wall -O2 evenodd_C.c -o evenodd_C

or

    $ gcc -Wall -O3 evenodd_C.c -o evenodd_C


### compile C code to "readable" assembly

`-fno-asynchronous-unwind-tables` tells gcc to omit the CFI meta
assembler directives it normally generates for exception or debugging
purposes.

`-masm=intel` tells it to use the more readable Intel syntax instead
of the default AT&T syntax.

    $ gcc -O3 -S -fno-asynchronous-unwind-tables -masm=intel evenodd_C.c -o evenodd_C.s


## Links

[x86 Assembly](http://en.wikibooks.org/wiki/X86_Assembly) wikibook,
good and short intro.

[What I Dislike About
GAS](http://x86asm.net/articles/what-i-dislike-about-gas/index.html)
(why to prefer Intel over AT&T syntax; confirmed by people on `##asm`
on freenode, and forum discussions about the article)

enter and leave:
[1](http://en.wikibooks.org/wiki/X86_Assembly/Control_Flow#Enter_and_Leave),
[2](https://en.wikipedia.org/wiki/X86_assembly_language)

[X86 calling conventions](https://en.wikipedia.org/wiki/X86_calling_conventions),
covers both x86 and AMD64

[System V Application Binary Interface, AMD64 Architecture Processor
Supplement](http://www.x86-64.org/documentation_folder/abi-0.99.pdf),
for more details on the AMD64 ABI (used by all operating systems
except Windows)

([Say hello to x64 Assembly](http://0xax.blogspot.ch/2014/08/say-hello-to-x64-assembly-part-1.html) (not used in the end))

([sandpile.org](http://www.sandpile.org/), good overviews on the x86 opcodes)
